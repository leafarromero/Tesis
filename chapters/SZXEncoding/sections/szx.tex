\subsection{The Scalable ZX-calculus}%
\label{sec:szx}

The ZX calculus~\cite{vdw_working_cs_zx} is a formal graphical language
that encodes linear maps between quantum states.
Multiple extensions to the calculus have been proposed.
We first present the base calculus with the grounded-ZX extension,
denoted \zxGND~\cite{ground},
to allow us to encode quantum state measurement operations.
A \zxGND\ diagram is generated by the following primitives,
in addition to parallel and serial composition:
\[
    \tikzfig{szx/elem/spiderZ} : n_1 \to m_1
    \qquad
    \tikzfig{szx/elem/spiderX} : n_1 \to m_1
\]
\[
    \tikzfig{szx/elem/hadamard} : 1_1 \to 1_1
    \qquad
    \tikzfig{szx/elem/ground} : 1_1 \to 0_1
\]
\[
    \tikzfig{szx/elem/wire} : 1_1 \to 1_1
    \qquad
    \tikzfig{szx/elem/cup} : 0_1 \to 2_1
\]
\[
    \tikzfig{szx/elem/cap} : 2_1 \to 0_1
    \qquad
    \tikzfig{szx/elem/swap} : 2_1 \to 2_1
    \qquad
    \tikzfig{szx/elem/empty} : 0_1 \to 0_1
\]
where $n_k$ represents the n-tensor of k-qubit registers,
the green and red nodes are called Z and X spiders,
$\alpha \in [0,2\pi)$ is the phase of the spiders,
and the yellow square is called the Hadamard node.
These primitives allow us to encode any quantum operation,
but they can become impractical when working with multiple qubit registers.

The SZX calculus~\cite{carette_szx-calculus_2019,carette_quantum_2021}
is a \textit{Scalable} extension to the ZX-calculus
that generalizes the primitives to work with arbitrarily sized qubit registers.
This facilitates the representation of diagrams with repeated structure
in a compact manner. 
Carette et al.~\cite{carette_quantum_2021} show that the scalable and grounded extensions
can be directly composed.
We will refer to the resulting $\szxGND$-calculus as SZX for simplicity.
%
Bold wires in a SZX diagram are tagged with a non-negative integer representing
the size of the qubit register they carry, and other generators are marked in bold 
to represent a parallel application over each qubit in the register.
Bold spiders with multiplicity $k$ are tagged with $k$-sized vectors of phases
$\overline\alpha = \alpha_1 :: \dots :: \alpha_k$.
The natural extension of the ZX generators correspond to the following primitives:
\[
    \tikzfig{szx/elem/spiderZ-szx} : n_k \to m_k
    \qquad
    \tikzfig{szx/elem/spiderX-szx} : n_k \to m_k
\]
\[
    \tikzfig{szx/elem/hadamard-szx} : 1_k \to 1_k
    \qquad
    \tikzfig{szx/elem/ground-szx} : 1_k \to 0_0
\]
\[
    \tikzfig{szx/elem/wire-szx} : 1_k \to 1_k
    \qquad
    \tikzfig{szx/elem/cup-szx} : 0_0 \to 2_k
\]
\[
    \tikzfig{szx/elem/cap-szx} : 2_k \to 0_0
    \qquad
    \tikzfig{szx/elem/swap-szx} : 1_k \otimes 1_l \to 1_l \otimes 1_k
    \qquad
    \tikzfig{szx/elem/empty} : 0_k \to 0_k
\]
Wires of multiplicity zero are equivalent to the empty mapping.
We may omit writing the wire multiplicity if it can be deduced by context. 

The extension defines two additional generators; a \textit{split} node to split
registers into multiple wires, and a function arrow to apply arbitrary functions
over a register. In this work we restrict the arrow functions to permutations
$\sigma : [0 \dots k) \to [0 \dots k)$ that rearrange the order of the wires.
Using the split node and the wire primitives can derive the rotated version,
which we call a \textit{gather}.
\[
    \tikzfig{szx/elem/split} : 1_{n+m} \to 1_n \otimes 1_m
\]
\[
    \tikzfig{szx/elem/gather} : 1_n \otimes 1_m \to 1_{n+m}
    \qquad
    \tikzfig{szx/elem/arrow} : 1_k \to 1_k
\]

The rewriting rules of the calculus imply that a SZX diagrams can be considered
as an open graph where only the topology of its nodes and edges matters.
%
In the translation process we will make repeated use of the following
reductions rules to simplify the diagrams:
\[
    \tikzfig{szx/rules/split-gather}
    \ \stackrel{\mathbf{(sg)}}{=}\ %
    \tikzfig{szx/rules/split-gather-2}
\]
\[
    \tikzfig{szx/rules/gather-split}
    \ \stackrel{\mathbf{(gs)}}{=}\ %
    \tikzfig{szx/rules/gather-split-2}
\]
  %
In an analogous manner, we will use a legless gather $\tikzfig{szx/gather0}$ to terminate wires with cardinality zero.
This could be encoded as the zero-multiplicity spider $\tikzfig{szx/spider0}$, which represents the empty mapping.

Refer to Appendix~\ref{sec:szx-extended} for a complete definition
of the rewriting rules and the interpretation of the SZX calculus.
%
Cf.~\cite{carette_quantum_2021} for a description of the calculus including the generalized arrow generators.

Carette et al.~\cite{carette_quantum_2021} showed that the SZX calculus
can encode the repetition of a function $f : 1_n \to 1_n$ an arbitrary number of times $k\geq 1$ as follows:
\[
    \tikzfig{szx/repeat}
    \quad=\quad%
    \left(\tikzfig{szx/repeat-2}\right)^k
\]
where $f^k$ corresponds to $k$ parallel applications of $f$.
With a simple modification this construction can be used to encode an accumulating map operation.
\begin{lemma}%
    \label{lem:accumap}
    Let $g : 1_n \otimes 1_s \to 1_{m} \otimes 1_s$ and $k\geq 1$, then
    
    \begin{adjustbox}{width=\textwidth}
    $$
    \tikzfig{szx/accumap}
    \quad=\quad%
    \tikzfig{szx/accumap-2}
    $$
    \end{adjustbox}
\end{lemma}
As an example, given a list $N = [n_1, n_2, n_3]$ and a starting accumulator value $x_0$,
this construction would produce the mapping $([n_1, n_2, n_3], x_0) \mapsto ([m_1, m_2, m_3], x_3)$ where
$(m_i, x_i) = g(n_i, x_{i-1})$ for $i \in [1,3]$.

% ------------------------------------------------------------------------------- %

\subsection{SZX diagram families and list instantiation}

We introduce the definition of a family of SZX diagrams $D: \N^k \to \diag$
as a function from $k$ integer \textit{parameters} to SZX diagrams.
We require the structure of the diagrams to be the same for all elements in the family,
parameters may only alter the wire tags and spider phases.
Partial application is allowed, we write $D(n)$ to fix the first parameter of $D$.

%\begin{example}
%    The following example describes a family of diagrams $D$ that applies z-rotations
%    with angle $\sfrac{\pi}{n}$ on $n+1$ qubits.
%    \[D := n \mapsto \tikzfig{szx/family-example}\]
%\end{example}

Since instantiations of a family share the same structure,
we can compose them in parallel by merging the different values of wire tags and spider phases.
We introduce a shorthand for instantiating a family of diagrams on multiple values
and combining the resulting diagrams in parallel.
This definition is strictly more general than the \textit{thickening endofunctor}
presented by Carette et al.~\cite{carette_quantum_2021},
which replicates a concrete diagram in parallel.
A \textit{list instantiation} of a family of diagrams $D: \N^{k+1} \to \diag$ over
a list $N$ of integers is written as $(D(n), n \in N)$.
This results in a family with one fewer parameter, $(D(n), n \in N): \N^k \to \diag$. 
We graphically depict a list instantiation as a dashed box in a diagram, as follows.
\[\tikzfig{szx/list-instantiation-box} := \tikzfig{szx/list-instantiation}\]

The definition of the list instantiation operator is given recursively
on the construction of $D$ in Figure~\ref{fig:list-instantiation}.
On the diagram wires we use $v(N)$ to denote the wire cardinality $\sum_{n \in N} v(n)$,
$\overrightarrow\alpha(N)$ for the concatenation of phase vectors
$\overrightarrow\alpha(n_1) :: \dots :: \overrightarrow\alpha(n_m)$,
and $\sigma(N)$ for the composition of permutations $\bigotimes_{n \in N} \sigma(n)$.
In general, a permutation arrow $\sigma(N,v,w)$ instantiated in concrete values
can be replaced by a reordering of wires between two gather gates%
using the rewrite rule $\bf{(p)}$.

\begin{figure}[tb]
\begin{mdframed}
    Given $D: \N^{k+1} \to \diag$, $N = [n_1, \dots, n_m] \in \N^m$,
    \[
        ((D_1 \otimes D_2)(n), n \in N) := (D_1(n), n \in N) \otimes (D_2(n), n \in N) 
        %
        \qquad
        %
        \tikzfig{szx/list-instantiation/wire}
        :=
        \tikzfig{szx/list-instantiation/wire-flat}
    \]
    \[
        ((D_2 \circ D_1)(n), n \in N) := (D_2(n), n \in N) \circ (D_1(n), n \in N) 
        %
        \qquad
        %
        \tikzfig{szx/list-instantiation/ground}
        :=
        \tikzfig{szx/list-instantiation/ground-flat}
    \]
    \[
        \tikzfig{szx/list-instantiation/hadam}
        :=
        \tikzfig{szx/list-instantiation/hadam-flat}
        %
        \qquad
        %
        \tikzfig{szx/list-instantiation/arrow}
        :=
        \tikzfig{szx/list-instantiation/arrow-flat}
    \]
    \[
        \tikzfig{szx/list-instantiation/spider-Z}
        :=
        \tikzfig{szx/list-instantiation/spider-Z-flat}
        %
        \qquad
        %
        \tikzfig{szx/list-instantiation/spider-X}
        :=
        \tikzfig{szx/list-instantiation/spider-X-flat}
    \]
    \[
        \tikzfig{szx/list-instantiation/gather}
        :=
        \tikzfig{szx/list-instantiation/gather-flat}
    \]
    Where $\sigma(N, v, w) \in \Ftwo^{v(N)+w(N) \times v(N)+w(N)}$ is the permutation defined as the matrix
    \[
        \sigma(N, v, w) = \begin{pmatrix}\sigma_f^N \vert \sigma_g^N \end{pmatrix}, \quad
        \sigma_f^{N} \in \Ftwo^{v(N)+w(N) \times v(N)},
        \ \sigma_g^{N} \in \Ftwo^{v(N)+w(N) \times w(N)}
    \]
    \[
    \begin{array}{llll}
        \sigma_f^{[\,]} = Id_0
        \quad &
        \sigma_f^{n::N'} =
            \begin{pmatrix}
                Id_{v(n)} & 0 \\
                0 & 0 \\
                0 & \sigma_f^{N'}
            \end{pmatrix}
        \quad &
        \sigma_g^{[\,]} = Id_0
        \quad &
        \sigma_g^{n::N'} =
            \begin{pmatrix}
                0 & 0 \\
                Id_{w(n)} & 0 \\
                0 & \sigma_g^{N'}
            \end{pmatrix}
    \end{array}
    \]
    \caption{Definition of the list instantiation operator.}%
    \label{fig:list-instantiation}
\end{mdframed}
\end{figure}

\begin{lemma}%
    \label{lem:list-instantiation}
    For any diagram family $D$, $n_0 : \N$, $N : \N^k$,
    \[
        \tikzfig{szx/list-instantiation-append}
        \;=\;
        \tikzfig{szx/list-instantiation-append-split}
    \]
\end{lemma}

\begin{lemma}%
    \label{lem:list-init-zero}
    A diagram family initialized with the empty list corresponds to the empty map.
    For any diagram family $D$,
    \[
        \tikzfig{szx/list-instantiation-empty}
        \;=\;
        \tikzfig{szx/list-instantiation-empty-flat}
    \]
\end{lemma}

\begin{lemma}%
    \label{lem:list-instantiation-linear}
    The list instantiation procedure on an $n$-node diagram family adds
    $\bigo(n)$ nodes to the original diagram.
\end{lemma}
