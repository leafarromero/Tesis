\section{Examples}

\subsection{Deutsch-Josza algorithm}

{\color{red} SMALL INTRODUCTION TO THE ALGORITHM}

We will do a comparison between the Deutsch-Josza algorithm written in different bases and see what information we can glean from the typing of the terms.

We first define the terms for the algorithm. The top level $\mathsf{Deutsch}$ abstraction, takes an oracle $U_f$  which inputs two qubits $\ket{x y}$ and outputs $\ket{x (y\oplus f(x))}$ where $\oplus$ denotes addition modulo 2. The circuit will output $\ket{0}$ on the first qubit if the function $f$ is balanced 
% TODO: Incluir en el apéndice los juicios de tipado para los términos
\begin{table*}
    \small
    \begin{align*}
        \mathsf{Deutsch} &:= 
        (\Lam{{f}}{\AbsBasis}{
                \LetP{x}{\B}{y}{\B}
                {(f (\Hd \ket{0}) (\Hd \ket{1}))}
                {\Pair{(\Hd x)}{y}}
        })\\
        \Hd &:= \Lam{x}{\B}{\case{x}{\ket{0}}{\ket{1}}{\ket{+}}{\ket{-}}}
    \end{align*}
    \caption{Deutsch algorithm term}
\end{table*}

On table \ref{tab:Oracles} we note the four possible oracles. $D_1$ and $D_4$ correspond to the 0 and 1 constant functions and $D_2$, $D_3$ to the identity and bit-flip respectively.

\begin{table*}
    \scriptsize
    \begin{align*}
        D_1 :=& \Lam{x}{\B}{\Lam{y}{\B}{\Pair{x}{y}}}\\
        D_2 :=& \Lam{x}{\B}{\Lam{y}{\B}{\cnot{x}{y}}}\\
        D_3 :=& \Lam{x}{\B}{\Lam{y}{\B}{\cnot{x}{(\pauliX{y})}}}\\
        D_4 :=& \Lam{x}{\B}{\Lam{y}{\B}{\Pair{x}{(\pauliX{y})}}}\\
        \text{Where:} &\\
        \cnot{}{} :=& \Lam{x}{\B}{\Lam{y}{\B}{
        \case{x}
        {\ket{0}}{\ket{1}}
        {\Pair{\ket{0}}{y}}{\Pair{\ket{1}}{\pauliX{y}}}}}\\
        \pauliX{} :=& \Lam{x}{\B}{\case{x}{\ket{0}}{\ket{1}}{\ket{1}}{\ket{0}}}
    \end{align*}
    
    \caption{Oracles implementing the four possible functions $f:\{0,1\}\mapsto\{0,1\}$}
    \label{tab:Oracles}
\end{table*}

Each of these oracles can be typed as $\B\to\B\to(\B\times\B)$. But since we are passing $\ket{+}$ and $\ket{-}$ as arguments, the typing we would be able to assign is: $\sharp\B\to\sharp\B\to(\B\otimes\B)$. This means that the final typing for $\mathsf{Deutsch}$ would be: $\TYP{}{\mathsf{Deutsch}}{(\sharp\B\Arr\sharp\B\Arr(\sharp\B\Arr\sharp\B))\Arr\sharp(\B\times\B)}$. This would seem to suggest that the result of the computation is a superposition of pairs of booleans.

However, this approach underutilizes the amount of information we have available. We know that the oracle will receive specifically the state $\ket{+-}$, and so we can rewrite the intervening terms taking this information into account. In table \ref{tab:DeutschShift} we restate the terms, but this time the abstractions and conditional cases are written in the basis $\XB=\{\ket{+},\ket{-}\}$.

\begin{table*}
    \footnotesize
    \[
    \begin{array}{r c l}
        \mathsf{Deutsch}&:=~&(\Lam{{U_f}}{\AbsBasis}{
                \LetP{x}{\XB}{y}{\XB}
                {(U_f \ket{+} \ket{-})}
                {\\ && \case{x}{\ket{+}}{\ket{-}}{\ket{0}}{\ket{1}}}})\\
        D_1 &:= &\Lam{x}{\XB}{\Lam{y}{\XB}{\Pair{x}{y}}}\\
        D_2 &:= &\Lam{x}{\XB}{\Lam{y}{\XB}{\cnotXB{x}{y}}}\\
        D_3 &:= &\Lam{x}{\XB}{\Lam{y}{\XB}{\cnotXB{x}{(\pauliXXB{y})}}}\\
        D_4 &:= &\Lam{x}{\XB}{\Lam{y}{\XB}{\Pair{x}{(\pauliXXB{y})}}}\\
        \multicolumn{3}{l}{\text{Where:}}\\
        \cnotXB{}{} &:=& \Lam{x}{\XB}{\Lam{y}{\XB}{
        \case{y}
        {\\ && \ket{+}}{\\ && \ket{-}}
        {\Pair{x}{\ket{+}}}{\Pair{\pauliZXB{x}}{\ket{-}} \\ &&}}}\\
        \pauliZXB{} &:=& \Lam{x}{\XB}{\case{x}{\ket{+}}{\ket{-}}{\ket{-}}{\ket{+}}}\\
        \pauliXXB{} &:=& \Lam{x}{\XB}{\case{x}{\ket{+}}{\ket{-}}{\ket{+}}{(-1)\cdot \ket{-}}}\\
    \end{array}
    \]
    \caption{Deutsch term and oracles in the shifted Hadamard basis.}
    \label{tab:DeutschShift}
\end{table*}

In this case, for each of the oracles we can assign the type $\XB\to\XB\to\XB\times\XB$ and type the term $\mathsf{Deutsch}$ as $(\XB\to\XB\to\XB\times\XB)\to\B$. There is a key difference here, the type of the oracles assure us that the result will be in the basis state $\XB\times\XB$. In other words, the result can either be a pair of $\ket{+}$ or $\ket{-}$ (up to a global phase). Since we know this fact, we can manipulate the result of $f$ as we would with classical bits, and discard the second component. 

Both functions are equivalent on an operational point of view. But reframing the into a different basis, allow us to give a more tight typing to the terms and more insight on how the algorithm works. If we analize the typing judgements, we observe that none of the variables has a $\sharp$ type. This has two consequences, first we can safely discard the second qubit and second, the Hadamard transform guarantees that the first qubit will yield a boolean. Stated differently, we can say that the Deutsch algorithm performs a classical computation on the Hadamard basis.

\subsection{Quantum teleportation}

The \emph{principle of deferred measurement} states that any quantum circuit involving the measurement of some qubit followed by a gate controlled by the outcome of this measurement is equivalent to another circuit in which no gates are controlled by previous measurement results. Instead, all gates are controlled by a quantum state. $\lambdaB$ does not implement a mechanism to measure states, but using the $\mathsf{case}$ constructor is possible to simulate these quantum controlled gates.

A notable example of an algorithm which makes use of classical controlled gates is the \emph{quantum teleportation}. In it, two agents (usually called Alice and Bob) share two parts of a Bell state and make use of the entanglement to move a quantum state from a qubit owned by Alice to a qubit owned by Bob. The quantum circuit representation of the algorithm is the following:

{\color{red} QUANTUM TELEPORTATION DIAGRAM}

The algorithm first 
