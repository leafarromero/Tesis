\section{Examples}\label{sec:examples}
%TODO: AGREGAR JUICIOS DE TIPADO Y DEMOSTRACIONES DE SUBTIPADO EN EL APÉNDICE.
\subsection{Deutsch's algorithm}\label{subsec:deutsch}
We begin with \emph{Deutsch's algorithm}, a canonical example that highlights
how basis types in the $\lambdaB$ calculus yield more informative typings for
quantum programs.
The algorithm is as follows.
We are given black-box access to an \emph{oracle}~$U_f$ that implements an
unknown Boolean function $f:\{0,1\}\to\{0,1\}$.  
The oracle can only be either \emph{constant} (both inputs map to the same
output) or \emph{balanced} (the two outputs differ).  
Classically, determining which case holds requires two queries to~$f$.  
Deutsch's algorithm decides this with a single query by exploiting quantum
superposition and interference.

Operationally, the oracle~$U_f$ acts as
\(
  U_f:\ket{xy}\mapsto \ket{x}\otimes\ket{y\oplus f(x)}
\),
where $\oplus$ is addition modulo~2.  
The textbook circuit prepares the state~$\ket{+-}$, applies~$U_f$, and
then applies a Hadamard on the first qubit before measuring it.  
The outcome is~$\ket{0}$ if~$f$ is constant and~$\ket{1}$ if~$f$ is balanced.

We begin with a standard implementation of this algorithm in $\lambdaB$.
We first encode the usual gates we will use:
\begin{align*}
  \Hd &:= \Lam{x}{\B}{\case{x}{\ket{0}}{\ket{1}}{\ket{+}}{\ket{-}}},\\
  \mathsf{NOT} &:= \Lam{x}{\B}{\case{x}{\ket{0}}{\ket{1}}{\ket{1}}{\ket{0}}},\\
  \mathsf{CNOT} &:= \Lam{x}{\B}{\Lam{y}{\B}{
    \case{x}{\ket{0}}{\ket{1}}
      {\Pair{\ket{0}}{y}}
      {\Pair{\ket{1}}{\pauliX{y}}}}}.
\end{align*}

We model the four possible oracles $U_f$ (two constant and two balanced):
\begin{align*}
  O_{\mathrm{const}\,0} &:= \Lam{x}{\B}{\Lam{y}{\B}{\Pair{x}{y}}},
  & O_{\mathrm{id}}       &:= \Lam{x}{\B}{\Lam{y}{\B}{\cnot{x}{y}}},\\
  O_{\mathrm{const}\,1} &:= \Lam{x}{\B}{\Lam{y}{\B}{\Pair{x}{(\pauliX{y})}}},
  & O_{\mathrm{flip}}     &:= \Lam{x}{\B}{\Lam{y}{\B}{\cnot{x}{(\pauliX{y})}}}.
\end{align*}

The standard Deutsch term prepares~$\ket{+-}$, calls the oracle, then
applies~$H$ on the first qubit and returns the (classical) first component:
\[
  \mathsf{Deutsch}_{\mathrm{std}} :=
  \Lam{f}{\AbsBasis}{
    \LetP{x}{\B}{y}{\B}
      {(f\,(\Hd\,\ket{0})\,(\Hd\,\ket{1}))}
      {\Pair{\Hd\,x}{y}}
  }.
\]

Each oracle above can be typed as
\(
  \basis{\B}\Arr\basis{\B}\Arr(\basis{\B}\times\basis{\B})
\),
but since the arguments we pass are $\ket{+}$ and $\ket{-}$ (superpositions),
the overall judgement we can derive for the application uses~$\sharp$:
\[
  \TYP{}{\mathsf{Deutsch}_{\mathrm{std}}}
  {(\sharp\basis{\B}\Arr\sharp\basis{\B}\Arr(\sharp\basis{\B}\times\sharp\basis{\B}))
   \Arr \sharp(\basis{\B}\times\basis{\B})}.
\]
This type is correct but coarse: it only guarantees that the result is a
unitary distribution of pairs of booleans.  Operationally we know more: the
first output is actually a basis bit ($\ket{0}$ or~$\ket{1}$) encoding whether
$f$ is constant or balanced, and the second output can be ignored.

Then, we can consider a basis-aware implementation with tighter typing.
The key observation is that the oracle is always called on the fixed state
$\ket{+-}$.  
Thus it is natural to write the program in the
$\XB=\{\ket{+},\ket{-}\}$ basis, letting the types track that we remain in a
basis state at the oracle boundary.

We define the same gates in the $\XB$ basis:
\begin{align*}
  \pauliZXB &:= \Lam{x}{\XB}{\case{x}{\ket{+}}{\ket{-}}{\ket{-}}{\ket{+}}},\\
  \pauliXXB &:= \Lam{x}{\XB}{\case{x}{\ket{+}}{\ket{-}}{\ket{+}}{-1\,\ket{-}}},\\
  \cnotXB &:= \Lam{x}{\XB}{\Lam{y}{\XB}{
    \case{y}{\ket{+}}{\ket{-}}
      {\Pair{x}{\ket{+}}}
      {\Pair{\pauliZXB{x}}{\ket{-}}}
  }}.
\end{align*}

We then rewrite the program and the four oracles in~$\XB$:
\begin{align*}
  \mathsf{Deutsch} &:= \Lam{f}{\AbsBasis}{ \LetP{x}{\XB}{y}{\XB}{(f\,\ket{+}\,\ket{-})} {\case{x}{\ket{+}}{\ket{-}}{\ket{0}}{\ket{1}}}},\\
\end{align*}
\vspace{-2\baselineskip}
\begin{align*}
  O_{\mathrm{const}\,0}^{\XB} &:= \Lam{x}{\XB}{\Lam{y}{\XB}{\Pair{x}{y}}},
  &O_{\mathrm{id}}^{\XB}\ \ &:= \Lam{x}{\XB}{\Lam{y}{\XB}{\cnotXB{x}{y}}},\\
  O_{\mathrm{const}\,1}^{\XB} &:= \Lam{x}{\XB}{\Lam{y}{\XB}{\Pair{x}{(\pauliXXB{y})}}},
  &O_{\mathrm{flip}}^{\XB} &:= \Lam{x}{\XB}{\Lam{y}{\XB}{\cnotXB{x}{(\pauliXXB{y})}}}.
\end{align*}

Now every oracle has the tight type
\(
  \basis{\XB}\Arr\basis{\XB}\Arr(\basis{\XB}\times\basis{\XB})
\),
and the program itself can be typed as
\[
  \TYP{}{\mathsf{Deutsch}}
  {(\basis{\XB}\Arr\basis{\XB}\Arr(\basis{\XB}\times\basis{\XB}))\Arr\basis{\B}}.
\]
Intuitively, the oracle---when fed with $\ket{+-}$---produces a pair of
basis states in~$\XB$ (up to a global phase).  Hence we can treat its output
classically: a single $\mathsf{case}$ on the first component suffices to return
a classical bit in the computational basis, with no need for a $\sharp$-type on
the result.

Both implementations are operationally equivalent: they compute a bit that
decides whether $f$ is constant or balanced.  The difference lies in the
\emph{precision} of their typings.  The standard version, expressed in~$\B$
with explicit Hadamards, forces $\sharp$ on the oracle's interface and thus
yields a result in~$\sharp(\basis{\B}\times\basis{\B})$.  The basis-aware
version states, via types, that the oracle is used on a fixed $\XB$-input and
therefore returns an $\XB$-basis pair; this lets us deterministically extract a
$\B$-basis bit.  In the typing derivation, no variable carries a $\sharp$-type:
(i) we may safely ignore the second qubit, and (ii) the first qubit is
guaranteed to be classical in~$\B$, reflecting the determinism of Deutsch's
algorithm.


\subsection{Quantum teleportation}

We now turn to the \emph{quantum teleportation protocol}, a cornerstone of
quantum information theory that exemplifies the manipulation of entangled
states and the transmission of quantum data through classical communication.
Within the $\lambdaB$ calculus, this protocol provides a natural setting to
combine pattern matching, linear handling of qubits, and the
\emph{deferred-measurement principle}.  
Using the $\mathsf{case}$ constructor together with the expressive typing
discipline introduced earlier, we can encode the teleportation process in a
way that remains both syntactically compact and semantically faithful to its
quantum-mechanical counterpart.

The deferred-measurement principle states that any quantum circuit can delay
its measurements without altering the final outcome.  
More precisely, any gate classically controlled by the result of a measurement
is equivalent to another circuit where the control qubit remains unmeasured,
acting coherently on all branches of the superposition.  
Although the $\lambdaB$ calculus has no primitive operation for measurement,
the $\mathsf{case}$ constructor allows us to simulate such classically
controlled gates by branching on basis states.

A canonical example that exploits this principle is the
\emph{quantum teleportation protocol}.  
Two agents (Alice and Bob) share an entangled pair of qubits forming a Bell
state.  
Using this shared entanglement and two bits of classical information,
Alice can transmit an unknown quantum state~$\ket{\psi}$ to Bob without
physically sending the qubit itself.  
The standard circuit implementing the protocol is shown below:
\[
  \Qcircuit @C=1em @R=.5em {
    \lstick{\ket{\psi}} & \qw & \qw & \ctrl{1} & \gate{H} & \meter & \control \cw \\
    \lstick{\ket{0}} & \qw & \targ & \targ & \meter & \control \cw \cwx[1] \\
    \lstick{\ket{0}} & \gate{H} & \ctrl{-1} & \qw & \qw & \targ & \gate{Z} \cwx[-2] \qw & \rstick{\ket{\psi}} \qw
  }
\]
The algorithm first creates the Bell state $\Phi^{+}$ between the second and
third qubits, then performs a Bell-basis measurement on the first and second
qubits.  
Operationally, this measurement is implemented by applying a CNOT gate followed
by a Hadamard on the first qubit (the adjoint of Bell-state preparation), and
then measuring both qubits.  
Depending on the pair of classical outcomes, a Pauli correction ($I$, $X$, $Z$,
or $ZX$) is applied to Bob's qubit to recover the original state~$\ket{\psi}$.

We can simulate the behaviour of this circuit in the $\lambdaB$ calculus by
defining a term that, instead of performing measurements, explicitly
describes the computation corresponding to each branch.  
A possible encoding is:
\begin{align*}
  &\mathsf{Teleport} :=
  \Lam{x}{\B}{
    \LetP{y_1}{\B}{y_2}{\B}{\Phi^{+}}{
      \mathsf{case}\;
        \Pair{x}{y_1}\;
        \mathsf{of}\\
         &\{ \Phi^{+} \mapsto \Pair{\Phi^{+}}{y_2},\;
          \Phi^{-} \mapsto \Pair{\Phi^{-}}{Z\,y_2},\;
	  \Psi^{+} \mapsto \Pair{\Psi^{+}}{X\,y_2},\;
	\Psi^{-} \mapsto \Pair{\Psi^{-}}{ZX\,y_2} \}
    }
  }.
\end{align*}

This term takes the input qubit~$\ket{\psi}$ and pairs it with one half of an
entangled Bell pair.  The $\mathsf{case}$ construct then matches the first two
qubits (the input and Alice's entangled qubit) against the Bell basis, and in
each branch applies the appropriate correction to Bob's qubit to
recover~$\ket{\psi}$.  The resulting term represents the same quantum
transformation as the circuit above but expressed without any explicit
measurement---instead, each branch encodes the coherent superposition of
possible measurement outcomes.

The $\lambdaB$ calculus allows us to abstract both the encoding and decoding
steps in the Bell basis, exploiting the deferred-measurement principle in a
type-safe way.  
Each branch of the $\mathsf{case}$ corresponds to a unitary transformation
preserving linearity and orthogonality, and the overall term has type
\[
  \TYP{}{\mathsf{Teleport}}
  {\sharp\basis{\B}\Arr(\sharp\basis{\Bell}\times\sharp\basis{\B})}.
\]
This type reflects that the protocol operates on superpositions of basis
states, producing a Bell-basis measurement outcome together with the recovered
qubit.  
In this way, the $\lambdaB$ calculus captures both the logical structure of
teleportation and its deferred-measurement semantics within a single, uniform
term language.

{\color{red} TODO: HABLAR DEL PAPER DE SIMON ACÁ EN UNA NUEVA SUBSECTION}
