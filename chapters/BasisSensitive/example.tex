\section{Examples}\label{sec:examples}

In this chapter we examine two use cases for the $\lambdaB$ calculus. First, taking advantage of the basis types defined in the type algebra, we are able to give a more expressive type to the term encoding Deutsch's algorithm. Second, we make use of the deferred measurement principle and pattern matching from the $\mathsf{case}$ constructor to write a descriptive term encoding the quantum teleportation protocol. 

\subsection{Deutsch's algorithm}

The Deutsch-Josza algorithm is a small example designed to showcase a problem which is solved exponentially faster by a quantum computer over a classical one. In it, we take as input a black box oracle which encodes a function $f:\{0,1\}^n\to\{0,1\}$. This function can be either \emph{constant} or \emph{balanced} (It outputs $0$ for exactly half the inputs and $1$ for the other half). The task to solve is to determine under which of the two classes the oracle falls.

In this section we will focus on the case where $n=1$, the original formulation of Deutsch's algorithm. However, this results can be generalized to any arbitrary $n$. The quantum circuit implementing the algorithm is the following:

\begin{align*}
    \Qcircuit @C=1em @R=.7em {
     \lstick{\ket{0}} & \qw & \gate{H} & \multigate{1}{U_f} & \qw & \gate{H} & \meter \\
     \lstick{\ket{1}} & \qw & \gate{H} & \ghost{U_f} & \qw & \qw & \qw
    }
\end{align*}

For a detailed discussion on the logic and operation of the algorithm, see {\color{red}(CITAR)}. We will do a comparison between Deutsch's algorithm written in different bases and see what information we can glean from the typing of the terms.

We first define the terms for the algorithm. The top level $\mathsf{Deutsch}$ abstraction, takes an oracle $U_f$  which inputs two qubits $\ket{x y}$ and outputs $\ket{x (y\oplus f(x))}$ where $\oplus$ denotes addition modulo 2. The circuit will output $\ket{0}$ on the first qubit if the function $f$ is balanced 
% TODO: Incluir en el apéndice los juicios de tipado para los términos
\begin{table*}
    \small
    \begin{align*}
        \mathsf{Deutsch} &:= 
        (\Lam{{f}}{\AbsBasis}{
                \LetP{x}{\B}{y}{\B}
                {(f (\Hd \ket{0}) (\Hd \ket{1}))}
                {\Pair{(\Hd x)}{y}}
        })\\
        \Hd &:= \Lam{x}{\B}{\case{x}{\ket{0}}{\ket{1}}{\ket{+}}{\ket{-}}}
    \end{align*}
    \caption{Deutsch algorithm term}
\end{table*}

On table \ref{tab:Oracles} we note the four possible oracles. $D_1$ and $D_4$ correspond to the oracles encoding the 0 and 1 constant functions and $D_2$, $D_3$ to the identity and bit-flip respectively.

\begin{table*}
    \scriptsize
    \begin{align*}
        D_1 :=& \Lam{x}{\B}{\Lam{y}{\B}{\Pair{x}{y}}}\\
        D_2 :=& \Lam{x}{\B}{\Lam{y}{\B}{\cnot{x}{y}}}\\
        D_3 :=& \Lam{x}{\B}{\Lam{y}{\B}{\cnot{x}{(\pauliX{y})}}}\\
        D_4 :=& \Lam{x}{\B}{\Lam{y}{\B}{\Pair{x}{(\pauliX{y})}}}\\
        \text{Where:} &\\
        \cnot{}{} :=& \Lam{x}{\B}{\Lam{y}{\B}{
        \case{x}
        {\ket{0}}{\ket{1}}
        {\Pair{\ket{0}}{y}}{\Pair{\ket{1}}{\pauliX{y}}}}}\\
        \pauliX{} :=& \Lam{x}{\B}{\case{x}{\ket{0}}{\ket{1}}{\ket{1}}{\ket{0}}}
    \end{align*}
    
    \caption{Oracles implementing the four possible functions $f:\{0,1\}\mapsto\{0,1\}$}
    \label{tab:Oracles}
\end{table*}

Each of these oracles can be typed as $\B\to\B\to(\B\times\B)$. But since we are passing $\ket{+}$ and $\ket{-}$ as arguments, the typing we would be able to assign is: $\sharp\B\to\sharp\B\to(\B\otimes\B)$. This means that the final typing for $\mathsf{Deutsch}$ would be: $\TYP{}{\mathsf{Deutsch}}{(\sharp\B\Arr\sharp\B\Arr(\sharp\B\Arr\sharp\B))\Arr\sharp(\B\times\B)}$. This would seem to suggest that the result of the computation is a superposition of pairs of booleans.

However, this approach underutilizes the amount of information we have available. We know that the oracle will receive specifically the state $\ket{+-}$, and so we can rewrite the intervening terms taking this information into account. In table \ref{tab:DeutschShift} we restate the terms, but this time the abstractions and conditional cases are written in the basis $\XB=\{\ket{+},\ket{-}\}$.

\begin{table*}
    \footnotesize
    \[
    \begin{array}{r c l}
        \mathsf{Deutsch}&:=~&(\Lam{{U_f}}{\AbsBasis}{
                \LetP{x}{\XB}{y}{\XB}
                {(U_f \ket{+} \ket{-})}
                {\\ && \case{x}{\ket{+}}{\ket{-}}{\ket{0}}{\ket{1}}}})\\
        D_1 &:= &\Lam{x}{\XB}{\Lam{y}{\XB}{\Pair{x}{y}}}\\
        D_2 &:= &\Lam{x}{\XB}{\Lam{y}{\XB}{\cnotXB{x}{y}}}\\
        D_3 &:= &\Lam{x}{\XB}{\Lam{y}{\XB}{\cnotXB{x}{(\pauliXXB{y})}}}\\
        D_4 &:= &\Lam{x}{\XB}{\Lam{y}{\XB}{\Pair{x}{(\pauliXXB{y})}}}\\
        \multicolumn{3}{l}{\text{Where:}}\\
        \cnotXB{}{} &:=& \Lam{x}{\XB}{\Lam{y}{\XB}{
        \case{y}
        {\\ && \ket{+}}{\\ && \ket{-}}
        {\Pair{x}{\ket{+}}}{\Pair{\pauliZXB{x}}{\ket{-}} \\ &&}}}\\
        \pauliZXB{} &:=& \Lam{x}{\XB}{\case{x}{\ket{+}}{\ket{-}}{\ket{-}}{\ket{+}}}\\
        \pauliXXB{} &:=& \Lam{x}{\XB}{\case{x}{\ket{+}}{\ket{-}}{\ket{+}}{(-1)\cdot \ket{-}}}\\
    \end{array}
    \]
    \caption{Deutsch term and oracles in the shifted Hadamard basis.}
    \label{tab:DeutschShift}
\end{table*}

In this case, for each of the oracles we can assign the type $\XB\to\XB\to\XB\times\XB$ and type the term $\mathsf{Deutsch}$ as $(\XB\to\XB\to\XB\times\XB)\to\B$. There is a key difference here, the type of the oracles assure us that the result will be in the basis state $\XB\times\XB$. In other words, the result can either be a pair of $\ket{+}$ or $\ket{-}$ (up to a global phase). Since we know this fact, we can manipulate the result of $f$ as we would with classical bits, and discard the second component. 

Both functions are equivalent on an operational point of view. But reframing the into a different basis, allow us to give a more tight typing to the terms and more insight on how the algorithm works. If we analize the typing judgements, we observe that none of the variables has a $\sharp$ type. This has two consequences, first we can safely discard the second qubit and second, the Hadamard transform guarantees that the first qubit will yield a boolean. This correlates with the fact that Deutsch's algorithm is deterministic and, we can statically ensure the result will be a basis vector.

\subsection{Quantum teleportation}

The \emph{principle of deferred measurement} states that any quantum circuit involving the measurement of some qubit followed by a gate controlled by the outcome of this measurement is equivalent to another circuit in which no gates are controlled by previous measurement results. Instead, all gates are controlled by a quantum state. $\lambdaB$ does not implement a mechanism to measure states, but using the $\mathsf{case}$ constructor is possible to simulate these quantum controlled gates.

A notable example of an algorithm which makes use of classical controlled gates is the \emph{quantum teleportation}. In it, two agents (usually called Alice and Bob) share two parts of a Bell state and make use of the entanglement to move a quantum state from a qubit owned by Alice to a qubit owned by Bob. The quantum circuit representation of the algorithm is the following:

\begin{align*}
    \Qcircuit @C=1em @R=.7em {
     \lstick{\ket{\phi}} & \qw & \qw & \ctrl{1} & \gate{H} & \meter & \control \cw \\
     \lstick{\ket{0}} & \qw & \targ & \targ & \meter & \control \cw \cwx[1] \\
     \lstick{\ket{0}} & \gate{H} & \ctrl{-1} & \qw & \qw & \targ & \control \cwx[-2] \qw & \rstick{\ket{\phi}} \qw
    }
\end{align*}

The algorithm first encodes the Bell state $\Phi^+$ onto the second and third qubit and then performs a Bell basis measurement on the first and second qubit. In order to do this, it first decomposes applying a CNOT gate followed by a Hadamard gate on the first qubit (The adjoint of the Bell state generation). Then the first and second qubit are measured, which informs the correction needed for the third qubit to recover the state $\phi$.

We can simulate the operation of the algorithm, via a $\lambda$-term which instead of outright measuring, describes the steps to take in each of the possible outcomes. A possible implementation is:

\begin{align*}
    (\Lam{x}{\B}{\LetP{y_1}{\B}{y_2}{\B}{\Phi^+}{ ~\mathsf{case } \Pair{x}{y_1}  ~\mathsf{ of }~\{ &\Phi^+\mapsto \Pair{\Phi^+}{y_2}\\
    &\Phi^-\mapsto \Pair{\Phi^-}{Z y_2}\\
    &\Psi^+\mapsto \Pair{\Psi^+}{X y_2}\\
    &\Psi^-\mapsto \Pair{\Psi^-}{ZX y_2}\\
    &\}}})
\end{align*}

The $\lambda$-term takes the state $\ket{\phi}$ as an argument, then matches the first qubit of the Bell pair and the $\ket{\phi}$ qubit, with the vectors of the Bell basis. In each branch, corrects the third qubit to recover the original $\ket{\phi}$ state. This is akin to controlling the correction with each of the Bell basis vectors.

The $\lambdaB$ calculus provides syntax which allows the abstraction of the steps encoding and decoding on the Bell basis. This technique makes full use of the deferred measurement principle and can be applied to measurements on arbitrary bases. The final type of the term is $\sharp\basis{\B}\Arr \sharp\basis{\Bell}\times \sharp\basis{\B}$.

{\color{red} BUSCAR OTROS EJEMPLOS DE ALGORITMOS QUE HAGAN MEDICIONES EN BASES NO COMPUTACIONALES.}