\section{Introduction}

% Motivation
The no-cloning theorem \cite{WoottersZurek1982} and the no-deleting theorem
\cite{PatiBraunstein2000} state it is impossible to copy or delete an arbitrary
qubit. There is, however, a subtlety: although arbitrary qubits
cannot be copied or deleted, this is possible for known---and, in the case of
deletion, separable---qubits. This implies that qubits with known values behave
as classical data and can be treated accordingly. Moreover, it suffices to know
the basis to which a qubit belongs in order to copy and, to some extent, delete it.

In most quantum programming languages, qubits are defined with respect to a
canonical basis—often referred to as the computational basis. In this setting,
classical bits correspond to the basis vectors, whereas qubits are unit-norm
linear combinations of them. Classical bits can be copied and deleted freely,
while such operations on arbitrary qubits are restricted.

% Work in this chapter
In this paper we introduce a quantum $\lambda$-calculus within the
quantum-control paradigm—by contrast with the classical-control one, where the
control flow is classical and cannot be superposed. Our approach is inspired by
a line of work on basis-sensitive quantum typing. The earliest system,
Lambda-S \cite{DiazcaroDowekRinaldiBIO19}, could distinguish whether a qubit
was in the computational basis, allowing duplication and erasure only in that
case. Later, Lambda-S$_1$
\cite{DiazcaroGuillermoMiquelValironLICS19,DiazCaroMalherbe2022} refined this
approach by restricting to unit-norm vectors, introducing higher-order
abstractions, and ensuring that terms of type qubit-to-qubit denote unitary
maps. More recently, the Lambda-SX calculus \cite{DiazcaroMonzonAPLAS25}
generalised Lambda-S to arbitrary non-entangled single-qubit bases, albeit
through a purely syntactic framework restricted to first order. The calculus we
present here extends these ideas to a unit-norm, higher-order setting over
multiple-qubit bases, grounded in a realisability semantics.

% How are planning to do this (Realizability technique)

The realisability methodology, originating with Kleene's work on Heyting
arithmetic \cite{KleeneJSL45}, provides a constructive framework that connects
operational semantics with type systems. In our context, it allows the
extraction of a sound type system directly from the reduction semantics of the
calculus, ensuring that safety properties hold by construction. The approach
proceeds as follows:
\begin{enumerate}
  \item Define a calculus with a deterministic evaluation strategy.
  \item Define types as sets of closed values in the language.
  \item Define the typing judgement so that asserting that a term has a given
  type is, by definition, to state that the term reduces to a value of that
  type.
\end{enumerate}
Each typing rule therefore corresponds to a provable theorem in this setting.
Rather than building ad hoc typing rules, the system is derived from the
computational content of the calculus, making it possible to define whole
families of type systems by proving the validity of new rules.

Following this approach, we enrich abstractions with explicit basis
decorations. Intuitively, the reduction system treats values expressed in the
chosen basis as classical data, while linear combinations of these values
represent quantum data and reduce linearly within the term. This refinement
enables duplication and erasure for qubits in known bases while maintaining
linear handling for unknown qubits.

% What do we aim to achieve? Plus the scope of the work
The objective of this work is twofold. First, to employ the extracted type
system to provide a more precise description of programs. Second, to take
advantage of the extended syntax to express quantum algorithms in a flexible
and compositional way, rather than merely translating circuits.

The idea of tracking basis information within quantum programming languages has
appeared in several forms across the literature.  
The work in~\cite{Perdrix2008} proposed an abstract model for static
entanglement analysis, where the basis of qubits is used to control duplication
and track non-entanglement properties.  
The approach in~\cite{DiazcaroMonzonAPLAS25} introduced a typed
$\lambda$-calculus that incorporates basis annotations into the type system,
ensuring linear handling of quantum data while providing strong
meta-theoretical guarantees.  
Our system generalises these ideas by allowing abstractions to range over
arbitrary---possibly entangled---bases, extending basis awareness beyond the
single-qubit setting and recovering higher-order computation.

A number of other frameworks support reasoning about multiple bases through
different paradigms. The green and red spiders in ZX-calculus correspond to
computations along the canonical and diagonal bases respectively. The 
Many-Worlds Calculus~\cite{ChardonnetdeVismeValironVilmartLMCS25} also accommodates
superpositions of programs but within a diagrammatic semantics.  
By contrast, our approach operates directly within a typed term calculus,
allowing basis transitions to be tracked syntactically.

From a categorical standpoint, the framework
in~\cite{HeunenKaarsgaard2021} models measurement and decoherence through
\emph{quantum information effects}, capturing basis change as a semantic
effect. Similarly,~\cite{CaretteJeunenKaarsgaardSabry2024} introduces
\textsc{Quantum}$\Pi$, a language combining two interpretations of a reversible
classical calculus—one per basis—via an effect construction.  
In both cases, basis sensitivity arises semantically.  
In contrast, $\lambdaB$ integrates it directly at the syntactic and typing
levels, ensuring that basis transformations are explicit in program structure.

Other languages aim to unify classical and quantum computation.
For instance,~\cite{VoichickLiRandHicks2023} generalises classical
control constructs and interprets duplication and discarding semantically as
entanglement and partial trace.  
Our calculus follows the opposite philosophy: linearity and duplicability are
syntactically restricted by the basis-sensitive type system, guaranteeing
coherent quantum control without relying on external semantic constraints.

Finally, related efforts in semantic characterisation—such as the fully
abstract model of~\cite{ClairambaultdeVisme2019} or the dual calculi
described in~\cite{ChoudhuryGay2025}—approach the logical foundations of
quantum computation from complementary angles.  
In contrast, $\lambdaB$ focuses on the syntactic distinction of bases and
superpositions within a unified quantum $\lambda$-calculus, providing a concrete
basis-sensitive typing and higher-order quantum control.


% Structure of the chapter
The chapter is organised as follows.  
\ref{sec:calculus} introduces the core language, its syntax, congruence rules,
and basis-dependent substitution.  
\ref{sec:reduction} defines the operational semantics, and
\ref{sec:model} presents the realisability model with unitary type semantics,
the characterisation of unitary operators, and the typing rules.  
\ref{sec:examples} presents some representative examples.
All omitted proofs appear in the appendices, and
\ref{sec:conclusion} concludes with final remarks and perspectives.