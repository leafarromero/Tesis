\subsection{Typing rules}    
In this section, we focus on enumerating and proving the validity of various
typing rules. The objective is to extract a reasonable set of rules that can
constitute a type system. We first need to lay the groundwork to properly define
what it means for a typing rule to be valid.

\begin{definition}
  A \emph{context} (denoted by capital Greek letters $\Gamma$, $\Delta$) is a
  finite mapping $\Gamma:\Var\to\Type\times\BasisType$ assigning a type and a
  basis to each variable in its domain. We write
  \(
    \Gamma = {x_1}^{{X_1}}:A_1,\dotsb, {x_n}^{{X_n}}:A_n
  \)
  to indicate that $\Gamma(x_i)=(A_i,\basis{X_i})$ for each~$i$.
\end{definition}

As in standard typing judgements, the context records the types of a term's
free variables. However, since substitution in our calculus depends on a basis,
we also wish to record that information. This is not strictly necessary, as the
basis with respect to which a variable is interpreted should not affect its
type. For instance, consider the following substitutions:
\begin{align*}
(\Lam{x}{\B}{\Pair{x}{y}})\ansubst{\ket{0}/y}{\B}
  &= \Lam{x}{\B}{\Pair{x}{\ket{0}}},\\
\text{and}\quad
(\Lam{x}{\B}{(x, y)})\ansubst{\ket{0}/y}{\XB}
  &= \tfrac{1}{\sqrt{2}}
    \bigl((\Lam{x}{\B}{\Pair{x}{\ket{+}}})
         + (\Lam{x}{\B}{\Pair{x}{\ket{-}}})\bigr).
\end{align*}
These terms are not syntactically identical, yet they are computationally
equivalent. 
Since typing via realisability captures computational behaviour,
their types coincide. Nevertheless, we retain basis information in contexts, as
it will simplify the forthcoming proofs.

\begin{definition}
  Given a context~$\Gamma$, its \emph{unitary semantics},
  denoted~$\sem{\Gamma}$, is the set of substitutions defined by
  \begin{align*}
    \sem{\Gamma}
    := 
    \{&\sigma~\text{substitution} \mid 
      \dom{\sigma} = \dom{\Gamma}
      \text{ and } \forall {x_i} \in \dom{\Gamma},\\
      &\Gamma(x_i) = (A_i, \basis{X_i})
      \text{ implies }
      \sigma(x_i) = \ansubst{\vv{v_i}/x_i}{{X_i}}
      \text{ for some }\vv{v_i} \in \sem{A_i}\}.
  \end{align*}
\end{definition}


To ensure a coherent treatment of quantum data, we must guarantee that qubits
are handled linearly. The first step is to identify which variables in the
context represent quantum data---those associated with a type of the
form~$\sharp A$. We call the subset of~$\Gamma$ composed of such variables its
\emph{strict domain}.

\begin{definition}
  The \emph{strict domain} of a context~$\Gamma$, denoted~$\sdom{\Gamma}$, is
  defined as
  \(
    \sdom{\Gamma} :=
    \{x \in \dom{\Gamma} \mid
    \sem{\Gamma(x)} = \sem{\sharp(\Gamma(x))}\}
  \).
\end{definition}

This definition relies on the idempotence of the~$\sharp$~operator
(\ref{thm:IdempotentSharp}).


A typing judgement $\Gamma\vdash \vv{t}:A$ is valid if it satisfies two
conditions.  First, every free variable of~$\vv{t}$ must belong to the domain
of~$\Gamma$, and every variable in the strict domain~$\sdom{\Gamma}$ must occur
in~$\vv{t}$.  This ensures that no information is erased and that all variables
are properly accounted for.  The linear treatment of quantum data is thus
enforced by substitution.

Second, for every substitution in the unitary semantics of~$\Gamma$, applying
it to~$\vv{t}$ must yield a term that reduces to a realizer of type~$A$.  This
condition ensures that the operational behaviour of the term within the context
is faithfully captured by the type.  Formally:

\begin{definition}[Typing judgement]
  A \emph{typing judgement} $\TYP{\Gamma}{\vv{t}}{A}$ is valid when:
    $\sdom{\Gamma}\subseteq\FV{\vv{t}}\subseteq\dom{\Gamma}$
    and
    for all $\sigma\in\sem{\Gamma}$, 
          $\vv{t}\ansubst{\sigma}{}\real A$.
\end{definition}

We are also interested in \emph{orthogonal terms}, that is, terms that reduce
to orthogonal values.  
We therefore introduce the following notion.

\begin{definition}
  An \emph{orthogonality judgement}
  $\ORTH{\Gamma}{\Delta_1}{\vv{t}}{\Delta_2}{\vv{s}}{A}$
  is said to be \emph{valid} when
  \begin{itemize}
    \item 
  the judgements
      $\TYP{\Gamma,\Delta_1}{\vv{t}}{A}$ and
      $\TYP{\Gamma,\Delta_2}{\vv{s}}{A}$ are valid, and
    \item for
      for every
      $\sigma\in\sem{\Gamma,\Delta_1}$ and
      $\tau\in\sem{\Gamma,\Delta_2}$,
      there exist value distributions $\vv{v},\vv{w}$ such that
      $\vv{t}\ansubst{\sigma}{}\eval\vv{v}$,
      $\vv{s}\ansubst{\tau}{}\eval\vv{w}$,
      and $\vv{v}\perp\vv{w}$.
  \end{itemize}
When both $\Delta_1$ and $\Delta_2$ are empty,
we just write
$\SORTH{\Gamma}{\vv{t}}{\vv{s}}{A}$.
\end{definition}



With these definitions in mind, a typing rule is \emph{valid} when valid
premises entail a valid conclusion.  
Although there are infinitely many valid rules (each corresponding to a theorem),
\ref{tab:TypingRules} presents a representative subset forming a reasonable
core typing system for the calculus, whose validity is stated below.

\begin{table}[t]
  \[
    \begin{array}{c}
      \infer[\snam{Axiom}]{\TYP{x^{X}:A}{x}{A}}{\basis{X}\leq A \text{ or }X=\AbsBasis}
      \qquad
	\infer[\snam{UnitLam}]{\TYP{\Gamma}{\sum_{i=1}^n \alpha_i (\Lam{x}{{X}}{\vv{t_i}})}{A\Arr B}}
	{\TYP{\Gamma,x^{X}:A}{\sum_{i=1}^{n}\alpha_i\vv{t_i}}{B}}
      \\
      \noalign{\medskip}
      \infer[\snam{App}]{\TYP{\Gamma,\Delta}{\vv{s}\,\vv{t}}{B}}
      {\TYP{\Gamma}{\vv{s}}{A\Arr B} & \TYP{\Delta}{\vv{t}}{A}}
      \qquad
      \infer[\snam{Pair}]{\TYP{\Gamma,\Delta}
      {\Pair{\vv{t}}{\vv{s}}}{A\times B}}{
	\TYP{\Gamma}{\vv{t}}{A}&\TYP{\Delta}{\vv{s}}{B}
      }
      \\
      \noalign{\medskip}
      \infer[\snam{LetPair}]{\TYP{\Gamma,\Delta} 
      {\LetP{x}{{X}}{y}{{Y}}{\vv{t}}{\vv{s}}}{C}}{
	\TYP{\Gamma}{\vv{t}}{A\times B}&
	\TYP{\Delta,x^{{X}}:A,y^{Y}:B}{\vv{s}}{C}
      }\\
      \noalign{\medskip}
      \infer[\snam{LetTens}]{\TYP{\Gamma,\Delta}
      {\LetP{x}{{X}}{y}{{Y}}{\vv{t}}{\vv{s}}}{\sharp C}}{
	\TYP{\Gamma}{\vv{t}}{\sharp(A\times B)}&
	\TYP{\Delta,x^{X}:\sharp A,y^{Y}:\sharp B}{\vv{s}}{C}
      }\\
      \noalign{\medskip}
      \infer[\snam{Case}]{\TYP{\Gamma,\Delta}
      {\gencase{\vv{t}}{\vv{v_1}}{\vv{v_n}}{\vv{s_1}}{\vv{s_n}}}{A}}{
	\TYP{\Gamma}{\vv{t}}{\genbasis{\vv{v_i}}{i=1}{n}}&
	\forall i,\ \TYP{\Delta}{\vv{s_i}}{A}
      }\\
      \noalign{\medskip}
      \infer[\snam{UnitCase}]{\TYP{\Gamma,\Delta}
      {\gencase{\vv{t}}{\vv{v_1}}{\vv{v_n}}{\vv{s_1}}{\vv{s_n}}}{\sharp A}}{
	\TYP{\Gamma}{\vv{t}}{\sharp \genbasis{\vv{v_i}}{i=1}{n}}&
	\forall i\neq j,\ \SORTH{\Delta}{\vv{s_i}}{\vv{s_j}}{A}
      }\\
      \noalign{\medskip}
      \infer[\snam{Sum}]
      {\TYP{\Gamma}{\sum_{i=1}^{n}\alpha_i \vv{t_i}}{\sharp A}}
      {\forall i\neq j,\, \SORTH{\Gamma}{\vv{t_i}}{\vv{t_j}}{A} &
      \sum_{i=1}^{n}|\alpha_i|^2 = 1}
      \\
      \noalign{\medskip}
      \infer[\snam{Contr}]{\TYP{\Gamma,x^{X}:{\basis{X}}}{\vv{t}\,[y:=x]}{B}}{
	\TYP{\Gamma,x^{X}:{\basis{X}},y^{X}:{\basis{X}}}{\vv{t}}{B}
      } 
      \qquad
	\infer[\snam{Weak}]{\TYP{\Gamma,x^{X}:\basis{X}}{\vv{t}}{C}}{
	  \TYP{\Gamma}{\vv{t}}{C}
	}
      \\
      \noalign{\medskip}
      \infer[\snam{Sub}]{\TYP{\Gamma}{\vv{t}}{B}}{\TYP{\Gamma}{\vv{t}}{A} & \SUB{A}{B}}
      \quad
      \infer[\snam{Equiv}]{\TYP{\Gamma}{\vv{s}}{A}}{
	\TYP{\Gamma}{\vv{t}}{A}& \vv t\equiv \vv s
      }
      \quad 
      \infer[\snam{Phase}]{\TYP{\Gamma}{e^{i\theta}\vv{t}}{A}}
      {\TYP{\Gamma}{\vv{t}}{A}}
    \end{array}
  \]
  \caption{Some valid typing rules}
  \label{tab:TypingRules}
\end{table}

\begin{theorem}\label{thm:TypingRulesValidity}
  All the typing rules in \ref{tab:TypingRules} are valid.
  \qed
\end{theorem}

The usual safety properties follow straightforwardly in this framework.
\emph{Confluence} is an immediate consequence of the reduction being
deterministic (cf.~\ref{rmk:determinism}).  
\emph{Strong normalisation} follows directly from the definition of a
realizer (cf.~\ref{def:Realizer}).  
\emph{Subject reduction} is also immediate: indeed, if
$\TYP{\Gamma}{\vv{t}}{A}$ and $\vv{t}\to\vv{u}$, then
$\TYP{\Gamma}{\vv{u}}{A}$ by definition.
However, if we restrict ourselves to a subset of typing rules—such as those
presented in \ref{tab:TypingRules}—we must
ensure that this restricted system still suffices to type all reducts of a
term, once the underlying realisability semantics is abstracted away.  In our
case, the rules proven valid in \ref{thm:TypingRulesValidity}
suffice to guarantee subject reduction, as
stated below.


\begin{theorem}[Subject reduction]\label{thm:SubjectReduction}
  If $\TYP{\Gamma}{\vv{t}}{A}$ can be derived using the set of rules in
  \ref{tab:TypingRules} and $\vv{t}\to\vv{u}$, then
  $\TYP{\Gamma}{\vv{u}}{A}$ can also be derived by the same set of rules.
  \qed
\end{theorem}
