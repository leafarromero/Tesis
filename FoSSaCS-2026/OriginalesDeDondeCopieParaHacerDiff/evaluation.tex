\section{Reduction system}\label{sec:reduction}

The reduction system implements a mechanism where every vector in the space is read in the corresponding basis attached to the abstraction. It does this by allowing an evaluation step only when the argument can be decomposed onto that basis. The system works modulo the congruence defined in \Cref{tab:Congruence}. We describe it in detail in \Cref{tab:Reduction}.

\begin{table*}[tb]
  \small
  
  \[
  \begin{array}{l}
    \text{If }\vec{t_i}\ansubst{\vec v/x}{A}\text{ is defined:}\\[3pt]
    \sum_{i=1}^{n}\alpha_i(\Lam{x}{A}{\vec{t_i}})\ \vec{v} \evalone \sum_{i=1}^{n} \alpha_i \vec{t_i}\ansubst{\vec v/x}{A}\\[12pt]
    \LetP{x}{B}{y}{B'}{\vec v}{\vec{t}}\evalone\vec{t}\ansubst{\vec{v}/x\otimes y}{B\otimes B'}\\[12pt]
    \text{If }\vec{v}\equiv\sum_{i=1}^{n}\alpha_i \vec{v_i}:\\[3pt]
    \gencase{\vec{v}}{\vec{v_1}}{\vec{v_n}}{\vec{t_1}}{\vec{t_2}}\evalone\sum_{i=1}^{n}\alpha_i \vec{t_i}\\
  \end{array}
  \]
  
  \[
  \begin{array}{c c c}
    \infer{s\,t\lra s\,\vec r}{t\lra \vec r}
      &
      \infer{t\,v\lra r\,v}{t\lra r}
      &
      \infer{\alpha\cdot t+\vec s\lra\alpha\cdot\vec r+\vec s}{t\lra\vec r}\\[5pt]
      \multicolumn{3}{c}{
      \infer{\LetP{x}{A}{y}{B}{t}{\vec{s}}\lra \LetP{x}{A}{y}{B}{\vec r}{\vec{s}}}{t\lra \vec r}}
      \\[5pt]
  \end{array}
  \]

  \[
  \begin{array}{c}
      \infer
      {\begin{array}{c c}
        \gencase{\vec t}{\vec v}{\vec w}{\vec s_1}{\vec s_2}\lra&\\
        \multicolumn{2}{r}{\gencase{\vec r}{\vec v}{\vec w}{\vec s_1}{\vec s_2}}
      \end{array}
      }
      {t\lra \vec r}
  \end{array}
  \]
  \caption{Reduction system}
  \label{tab:Reduction}
\end{table*}

The three main rules are the $\beta$-reduction, $\mathsf{let}$-destructor and $\mathsf{case}$ pattern matching. The $\lambda$ abstraction and $\mathsf{let}$ construct both attach an orthonormal basis to the variables they are binding. These bases keep track of which vectors it considers as classical data. Any $\C$-combination of them will be treated as quantum data, meaning, linearly. 

The only exception is in the case of higher order reductions. Since we do not have defined orthogonal bases for programs, we introduce a special basis $\AbsBasis$ which acts as the traditional computational basis. We can think of it as being composed of every single pure value. For example:
%PENSAR Y REEMPLAZAR CON ALGÚN EJEMPLO MÁS CONCRETO E INTERESANTE.
\begin{align*}
  \sum_{i=1}^{n}\alpha_i(\Lam{x}{\AbsBasis}{\vec{t_i}}) \sum_{j=1}^{m}\beta_j&(\Lam{y}{\basis{X}}{\vec{s_j}}) \evalone\\
  &\sum_{i=1}^n\sum_{j=1}^{m}\alpha_i\beta_j \vec{t_i}[(\Lam{y}{\basis{X}}{\vec{s_j}})/x]
\end{align*}

The $\mathsf{case}$ pattern matching controls the flow of programs. It generalizes the $\mathsf{if-then-else}$ branching. However, we do not consider fixed true or false values. Each operator will keep track of a set of orthogonal values. Then it will test the argument for equality against each vector and choose the matching branch. If the argument is a linear combination of several vectors, the result will be the corresponding linear combination of branches. For example:

\[
  \case{\ket{-}}{\ket{0}}{\ket{1}}{\vec{t_1}}{\vec{t_2}} \evalone
  \frac{1}{\sqrt{2}}\cdot\vec{t_1} - \frac{1}{\sqrt{2}}\cdot\vec{t_2}
\]

The advantage of this general approach over a binary conditional is the possibility to match against several vectors simultaneously. For boolean tuples, it makes no difference since we can treat each component independently. However, there are orthogonal bases which cannot be written as the product of two smaller bases themselves. In this case, the general $\mathsf{case}$ allows us match against these vectors. For example:

\begin{align*}
  \mathsf{case}\ \vec{v}\ \mathsf{of}\ \{ 
  &\frac{\ket{00} + \ket{11}}{2}\mapsto \vec{t_1} \mid\\
  &\frac{\ket{00} - \ket{11}}{2}\mapsto \vec{t_2} \mid\\
  &\frac{\ket{01} + \ket{10}}{2}\mapsto \vec{t_3} \mid\\
  &\frac{\ket{01} - \ket{10}}{2}\mapsto \vec{t_4} \}
\end{align*}

This particular set of four vectors is called the \textit{Bell basis}. It is useful in the field of quantum communication. In a later section, we will explore the quantum teleportation algorithm which heavily relies on these states. 

Defining the system in this way determines a strategy in the \textit{call-by-value} family, which we dub \textit{call-by-arbitrary-basis}. Note that evaluation is weak, meaning that no reduction occurs under lambda, pairs, let or conditional constructors. This prevents unnecessary work, reducing sub-terms that may or may not be utilized.

The congruence relation on terms gives rise to different redexes. However, we can show that the relation $\equiv$ commutes with the reflexive-transitive closure of the reduction $\evalone$ (We shall note $\eval$ as this reflexive-transitive closure). In other words, equivalence is preserved by the reduction $\eval$.

\begin{theorem}[Reduction preserves equivalence]
  Let $\vec{t}$ and $\vec{s}$ be closed term distributions such that $\vec{t}\equiv\vec{s}$. If $\vec{t}\evalone\vec{v}$, and $\vec{s}\evalone\vec{w}$, where $\vec{v},\vec{w}$ are value distributions. Then $\vec{v}\equiv\vec{w}$. Diagrammatically:

\[
  \begin{tikzcd}
   \vec{t} \arrow[d,twoheadrightarrow]&[-2.5em] \equiv &[-2.5em] \vec{s}\arrow[d,twoheadrightarrow]\\
   \vec{v}& \equiv & \vec{w}
  \end{tikzcd}
\]
\end{theorem}

\begin{proof}
  Proof by induction of the length of the chain:
  \[
  \vec{t}\equiv\vec{q_1}\equiv\dotsb\equiv\vec{q_n}\equiv\vec{s}
  \]
  
  \begin{description}
    \item[$n=0$:] Then, $\vec{t} = \vec{s}$. The vectors are not only equivalent, they are syntactically equal. In which case, $\vec{v}=\vec{w}$.

    \item[$n>0$:] Then, there exists $\vec{q_i}$ such that $\vec{t}\equiv\dotsb\equiv\vec{q_i}\equiv\dotsb\equiv\vec{s}$. By inductive hypothesis:
    \[
    \begin{tikzcd}
      \vec{t}\arrow[dd, twoheadrightarrow] &[-2.5em]\equiv\dotsb\equiv &[-2.5em]\vec{q_i}\arrow[dd, twoheadrightarrow]&[-2.5em] \equiv\dotsb\equiv &[-2.5em] \vec{s}\arrow[dd]\\[-1em]
      & \text{HI} & & \text{HI} &\\
      \vec{v} &\equiv& \vec{u} &\equiv& \vec{w}\\[-1em]
    \end{tikzcd}
    \]\qedhere
    \end{description}
\end{proof}

\begin{convention}
  With the previous result in mind, we will consider term distributions modulo the $\equiv$ congruence. This will not affect distributions under $\lambda$-abstractions or case conditionals which we only consider up to $\alpha$-conversion. Notice that reduction modulo $\equiv$ is deterministic.
\end{convention}
